<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
      th:replace="~{layout :: layout(~{::title}, ~{::main})}">
<head>
    <title th:text="'Chat with ' + ${friendUser.firstName} + ' ' + ${friendUser.lastName}">Private Chat</title>
    </head>
<body>

    <main th:fragment="main" class="px-4 py-6 md:px-6 md:py-8">
        <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between mb-5 pb-4 border-b border-gray-200 gap-4">
             <div class="flex items-center space-x-3 group"> <div class="w-10 h-10 rounded-full overflow-hidden border-2 border-gray-200 bg-gray-100 flex items-center justify-center flex-shrink-0">
                     <img th:if="${friendUser.profilePicturePath != null}"
                          th:src="@{/download/profile/{filename}(filename=${friendUser.profilePicturePath})}"
                          alt="Pic"
                          class="w-full h-full object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                     <div th:unless="${friendUser.profilePicturePath != null}" class="w-full h-full flex items-center justify-center">
                        <i class="fas fa-user text-lg text-gray-400"></i> </div>
                 </div>
                 <div>
                     <a th:href="@{/profile/{username}(username=${friendUser.username})}" class="hover:no-underline">
                        <h2 class="text-xl font-semibold text-gray-800 group-hover:text-purple-700 transition-colors duration-150" th:text="${friendUser.firstName + ' ' + friendUser.lastName}">Friend Name</h2>
                     </a>
                     <div class="text-xs mt-1 flex items-center flex-wrap gap-x-3 gap-y-1 text-gray-500">
                         <span th:each="role : ${friendUser.roles}"
                               th:text="${#strings.capitalize(#strings.toLowerCase(role.name.replace('ROLE_', '')))}"
                               class="inline-block bg-indigo-100 text-indigo-800 font-medium px-2 py-0.5 rounded-full">Role</span>
                         <span th:if="${friendUser.studentId != null and #lists.contains(friendUser.roles.![name], 'ROLE_STUDENT')}"
                               class="inline-flex items-center">
                            <i class="fas fa-id-card mr-1 text-gray-400"></i>
                            ID: <span class="ml-1" th:text="${friendUser.studentId}">Student ID</span>
                         </span>
                         <span th:if="${commonClassesCount != null and commonClassesCount > 0}"
                               class="inline-flex items-center">
                             <i class="fas fa-link mr-1 text-gray-400"></i>
                             <span th:text="${commonClassesCount} + ' common'">0 common</span>
                         </span>
                     </div>
                 </div>
            </div>
            <a th:href="@{/friends}" class="text-sm font-medium text-purple-600 hover:text-purple-800 hover:underline flex-shrink-0 whitespace-nowrap mt-2 sm:mt-0">
                &larr; Back to Friends
            </a>
        </div>

        <div class="bg-white p-4 sm:p-6 rounded-lg shadow-md border border-gray-200">
            <div id="chatStatus" class="system-message text-xs border-b border-gray-200 pb-2 mb-3">Connecting...</div>
            <div id="privateChatBox" class="h-[60vh] overflow-y-auto mb-4 pr-2">
                <div id="privateMessageList" class="flex flex-col gap-3"> <p class="system-message">Loading history...</p>
                </div>
            </div>
            <div id="chatInputArea" class="mt-4 pt-4 border-t border-gray-200">
                <div id="fileUploadArea" class="mb-2 p-2 border border-dashed border-gray-300 rounded hidden">
                    <label for="attachmentFile" class="text-sm font-medium text-gray-700 mr-2">Attach File:</label>
                    <input type="file" id="attachmentFile" name="attachmentFile" class="text-sm">
                </div>
                <div class="flex items-end space-x-2">
                     <textarea id="messageInput" rows="1" placeholder="Connecting..." disabled
                              class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500 resize-none text-sm"
                              style="min-height: 42px; max-height: 120px;"></textarea>
                     <button id="sendButton" class="btn btn-primary flex-shrink-0" disabled>
                        <i class="fas fa-paper-plane"></i>
                        <span class="sr-only">Send</span>
                     </button>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>

        <script th:inline="javascript">
        /*<![CDATA[*/

        // --- Constants ---
        const currentUsername = /*[[${currentUsername}]]*/ 'error_currentUser';
        const friendUsername = /*[[${friendUser.username}]]*/ 'error_friendUser';
        const friendFirstName = /*[[${friendUser.firstName}]]*/ 'Friend';
        const currentUserProfilePicPath = /*[[${loggedInUser?.profilePicturePath}]]*/ null; // Current user's path
        const profilePicBaseUrl = '/download/profile/';
        const defaultProfileIconHTML = '<i class="fas fa-user text-lg text-gray-400"></i>'; // Default icon HTML

        // --- DOM Elements ---
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const chatStatus = document.getElementById('chatStatus');
        const messageList = document.getElementById('privateMessageList');
        const chatBox = document.getElementById('privateChatBox');

        // --- State ---
        let stompClient = null;
        let isConnected = false;
        let subscription = null;

        // --- Functions ---
        function disableChatInput(message = "Connecting...") {
            messageInput.disabled = true;
            sendButton.disabled = true;
            messageInput.placeholder = message;
         }
        function enableChatInput() {
            messageInput.disabled = false;
            sendButton.disabled = false;
            messageInput.placeholder = "Type your message...";
            messageInput.focus();
        }
        function updateStatus(text, isError = false) {
             if (chatStatus) {
                chatStatus.textContent = text;
                chatStatus.className = 'system-message text-xs border-b border-gray-200 pb-2 mb-3'; // Reset classes
                if (isError) chatStatus.classList.add('error');
                chatStatus.style.display = text ? 'block' : 'none';
            }
        }
        function connect() {
            console.log("Attempting private chat WebSocket connection...");
            disableChatInput("Connecting...");
            updateStatus("Connecting...");
            if (typeof SockJS === 'undefined' || typeof Stomp === 'undefined') {
                console.error("SockJS or StompJS library not loaded!");
                updateStatus("Chat library error. Please refresh.", true);
                disableChatInput("Library Error"); return;
            }
            try {
                const socket = new SockJS('/ws');
                stompClient = Stomp.over(socket);
                stompClient.debug = null;
                stompClient.connect({}, onConnected, onError);
                stompClient.ws.onclose = function(event) {
                    console.warn("WebSocket connection closed.", event);
                    isConnected = false;
                    disableChatInput("Connection lost");
                    updateStatus("Connection lost. Please refresh.", true);
                };
            } catch (error) {
                console.error("Error initializing WebSocket client:", error);
                updateStatus(`Initialization Error: ${error.message}. Please refresh.`, true);
                disableChatInput("Initialization Error");
            }
        }
        async function onConnected(frame) {
             isConnected = true;
            console.log('Private Chat WebSocket Connected!', frame);
            updateStatus("Connected. Loading history...");
            try {
                const privateQueue = '/user/queue/private';
                console.log(`Subscribing to private queue: ${privateQueue}`);
                subscription = stompClient.subscribe(privateQueue, onMessageReceived, (subErrorFrame) => {
                    const subErrorMessage = subErrorFrame?.headers?.message || "Unknown subscription error";
                    console.error("Subscription error frame:", subErrorFrame);
                    updateStatus(`Error subscribing: ${subErrorMessage}`, true);
                    disableChatInput("Subscription Error");
                });
                if (!subscription?.id) console.warn("Subscription might have failed silently.");
                else console.log("Subscription successful. ID:", subscription.id);
                await loadChatHistory();
                updateStatus("");
                enableChatInput();
                console.log("Private chat initialized.");
            } catch (error) {
                console.error("Error during post-connection setup:", error);
                updateStatus(`Error setting up chat: ${error.message || 'Setup failed'}. Please refresh.`, true);
                disableChatInput("Setup Error");
            }
        }
        function onError(error) {
            isConnected = false;
            console.error('WebSocket Connection Error:', error);
            messageList.innerHTML = '';
            const errorMessage = (typeof error === 'string' ? error : error?.headers?.message) || 'Connection failed';
            updateStatus(`Could not connect: ${errorMessage}. Check console and refresh.`, true);
            disableChatInput("Connection Failed");
        }
        async function loadChatHistory() {
            console.log("Loading private chat history...");
            messageList.innerHTML = '<p class="system-message">Loading history...</p>';
            try {
                const response = await fetch(`/chat/private/history/${friendUsername}`);
                console.log("History fetch response status:", response.status);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to load history (${response.status}): ${errorText}`);
                }
                const history = await response.json();
                console.log("History data received:", history);
                messageList.innerHTML = '';
                if (history.length === 0) {
                    const noMsgP = document.createElement('p');
                    noMsgP.className = 'system-message';
                    noMsgP.textContent = "No messages in this conversation yet.";
                    messageList.appendChild(noMsgP);
                } else {
                    history.forEach(displayMessage);
                }
                scrollToBottom(true);
                console.log("Chat history loaded and displayed.");
            } catch (error) {
                console.error('Error loading or processing chat history:', error);
                messageList.innerHTML = `<p class="system-message error">Error loading history: ${error.message || 'Unknown error'}</p>`;
                throw error;
            }
        }

        // ===== displayMessage FUNCTION v6 (Focus on DOM creation) =====
        function displayMessage(msgDto) {
            try {
                const messageRowDiv = document.createElement('div');
                messageRowDiv.classList.add('message-row');
                const isMyMessage = msgDto.senderUsername === currentUsername;
                messageRowDiv.classList.add(isMyMessage ? 'my-message-row' : 'other-message-row');

                // --- Avatar Logic ---
                const avatarElement = document.createElement('div');
                avatarElement.classList.add('message-avatar'); // Use class from layout.html
                let picPath = isMyMessage ? currentUserProfilePicPath : msgDto.senderProfilePicPath; // Use DTO's path for sender
                let altText = (isMyMessage ? "Your" : (msgDto.senderFirstName || msgDto.senderUsername)) + "'s avatar";

                if (picPath) {
                    const img = document.createElement('img');
                    img.className = 'w-full h-full object-cover block rounded-full'; // Tailwind classes
                    img.src = profilePicBaseUrl + picPath;
                    img.alt = altText;
                    img.onerror = function() {
                        // Fallback to icon if image fails
                        this.parentElement.innerHTML = defaultProfileIconHTML;
                     };
                    avatarElement.appendChild(img);
                } else {
                    // Default icon if no path
                    avatarElement.innerHTML = defaultProfileIconHTML;
                }
                // --- End Avatar Logic ---

                // Bubble
                const messageBubble = document.createElement('div');
                messageBubble.classList.add('message-bubble');

                // --- Sender Details ---
                const senderDetailsDiv = document.createElement('div');
                senderDetailsDiv.classList.add('message-sender-details');

                const senderNameSpan = document.createElement('span');
                senderNameSpan.classList.add('sender-name');
                senderNameSpan.textContent = isMyMessage ? "You" : (msgDto.senderFirstName || msgDto.senderUsername); // Use name from DTO
                senderDetailsDiv.appendChild(senderNameSpan);

                const senderInfoSpan = document.createElement('span');
                senderInfoSpan.classList.add('sender-info');
                if (msgDto.senderRole === 'Student' && msgDto.senderStudentId) {
                    senderInfoSpan.textContent = `(ID: ${msgDto.senderStudentId})`;
                } else if (msgDto.senderRole && msgDto.senderRole !== 'System') {
                    senderInfoSpan.textContent = `(${msgDto.senderRole})`;
                }
                if (senderInfoSpan.textContent) {
                    senderDetailsDiv.appendChild(senderInfoSpan);
                }
                messageBubble.appendChild(senderDetailsDiv);

                // --- Content ---
                if (msgDto.content) {
                    const contentElement = document.createElement('span');
                    contentElement.classList.add('message-content');
                    // Basic HTML escaping
                    contentElement.textContent = String(msgDto.content).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    messageBubble.appendChild(contentElement);
                }

                // --- Attachment ---
                if (msgDto.attachmentUrl && msgDto.attachmentOriginalFilename) {
                    const attachmentDiv = document.createElement('div');
                    attachmentDiv.className = 'mt-1'; // Tailwind margin
                    const link = document.createElement('a');
                    link.href = msgDto.attachmentUrl;
                    link.target = "_blank";
                    link.className = 'inline-flex items-center p-1 px-2 bg-gray-100 hover:bg-gray-200 rounded text-xs text-gray-600 no-underline'; // Tailwind classes
                    const safeFilename = String(msgDto.attachmentOriginalFilename).replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    link.innerHTML = `<i class="fas fa-paperclip mr-1 text-gray-500"></i> ${safeFilename}`;
                    attachmentDiv.appendChild(link);
                    messageBubble.appendChild(attachmentDiv);
                }

                // --- Append elements to row ---
                if (isMyMessage) {
                    messageRowDiv.appendChild(messageBubble);
                    messageRowDiv.appendChild(avatarElement);
                } else {
                    messageRowDiv.appendChild(avatarElement);
                    messageRowDiv.appendChild(messageBubble);
                }

                // --- Append row to list ---
                messageList.appendChild(messageRowDiv);

            } catch (error) {
                console.error("Error rendering message:", error, msgDto);
                // Optionally display an error message in the chat UI
                const errorDiv = document.createElement('div');
                errorDiv.className = 'system-message error';
                errorDiv.textContent = '[Error displaying message]';
                messageList.appendChild(errorDiv);
            }
        }
        // ===== END displayMessage FUNCTION =====

        function scrollToBottom(force = false) {
             if (force || (chatBox.scrollHeight - chatBox.scrollTop < chatBox.clientHeight + 150)) {
                setTimeout(() => { chatBox.scrollTop = chatBox.scrollHeight; }, 50);
             }
        }

        // ===== sendMessage FUNCTION with Hardcoded Destination =====
        function sendMessage() {
             const messageContent = messageInput.value.trim();
             console.log("sendMessage called. Content:", messageContent); // Log content

            // Check connection status
            if (!isConnected || !stompClient || !stompClient.connected) {
                console.warn("Send message aborted. Conditions not met:", {
                    isConnected: isConnected,
                    stompClientExists: !!stompClient,
                    stompClientConnected: stompClient ? stompClient.connected : 'N/A'
                });
                if (!chatStatus.classList.contains('error')) {
                    updateStatus("Cannot send message: Not connected.", true);
                }
                return;
            }
            // Don't send empty messages
            if (!messageContent) {
                 console.log("Send message aborted: Empty content.");
                return;
            }

            // Prepare DTO
            const messageDto = {
                senderUsername: currentUsername,
                receiverUsername: friendUsername,
                content: messageContent
            };

            try {
                console.log("Attempting stompClient.send to /app/private.chat with DTO:", messageDto);
                // Use the literal string directly
                stompClient.send('/app/private.chat', {}, JSON.stringify(messageDto));
                console.log("stompClient.send executed successfully.");
                messageInput.value = '';
                adjustTextareaHeight();
            } catch (sendError) {
                // This catch block will now log the specific error
                console.error("Error sending message via STOMP:", sendError);
                updateStatus("Error sending message.", true);
            }
            messageInput.focus();
        }
        // ===== END sendMessage FUNCTION =====

        function onMessageReceived(payload) {
             console.log('Raw private message received:', payload);
            try {
                const message = JSON.parse(payload.body);
                if ((message.senderUsername === currentUsername && message.receiverUsername === friendUsername) ||
                    (message.senderUsername === friendUsername && message.receiverUsername === currentUsername))
                {
                    displayMessage(message);
                    scrollToBottom();
                } else {
                    console.log("Received message not for this chat window:", message);
                }
            } catch (e) {
                console.error("Error parsing received private message:", e, payload.body);
                updateStatus("Received an unreadable message.", true);
            }
        }
        function adjustTextareaHeight() {
            messageInput.style.height = 'auto';
            messageInput.style.height = (messageInput.scrollHeight) + 'px';
        }

        // --- Event Listeners ---
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                sendMessage();
                e.preventDefault();
            }
        });
        messageInput.addEventListener('input', adjustTextareaHeight);

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM fully loaded. Initializing private chat script...");
             adjustTextareaHeight();
             setTimeout(connect, 50);
        });

        /*]]>*/
        </script>
    </main>

</body>
</html>
